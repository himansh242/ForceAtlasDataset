        -:    0:Source:../../src/RPGraph.hpp
        -:    0:Graph:obj/graph_viewer.gcno
        -:    0:Data:obj/graph_viewer.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: ==============================================================================
        -:    3:
        -:    4: RPGraph.hpp
        -:    5: Copyright Â© 2016, 2017, 2018  G. Brinkmann
        -:    6:
        -:    7: This file is part of graph_viewer.
        -:    8:
        -:    9: graph_viewer is free software: you can redistribute it and/or modify
        -:   10: it under the terms of version 3 of the GNU Affero General Public License as
        -:   11: published by the Free Software Foundation.
        -:   12:
        -:   13: graph_viewer is distributed in the hope that it will be useful,
        -:   14: but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16: GNU Affero General Public License for more details.
        -:   17:
        -:   18: You should have received a copy of the GNU Affero General Public License
        -:   19: along with graph_viewer.  If not, see <https://www.gnu.org/licenses/>.
        -:   20:
        -:   21: ==============================================================================
        -:   22:*/
        -:   23:
        -:   24:
        -:   25:#ifndef RPGraph_hpp
        -:   26:#define RPGraph_hpp
        -:   27:#include <vector>
        -:   28:#include <string>
        -:   29:#include <unordered_map>
        -:   30:
        -:   31:namespace RPGraph
        -:   32:{
        -:   33:    // Type to represent node IDs.
        -:   34:    // NOTE: we limit to 4,294,967,296 nodes through uint32_t.
        -:   35:    typedef uint32_t nid_t;
        -:   36:
        -:   37:    // Type to represent edge IDs.
        -:   38:    // NOTE: uint32_t limits density to 50% for directed graphs.
        -:   39:    typedef uint32_t eid_t;
        -:   40:
        -:   41:    // Virtual base class to derive different Graph types from.
        -:   42:    class Graph
        -:   43:    {
        -:   44:        public:
        -:   45:            virtual nid_t num_nodes() = 0;
        -:   46:            virtual nid_t num_edges() = 0;
        -:   47:            virtual nid_t degree(nid_t nid) = 0;
        -:   48:            virtual nid_t in_degree(nid_t nid) = 0;
        -:   49:            virtual nid_t out_degree(nid_t nid) = 0;
        -:   50:            virtual std::vector<nid_t> neighbors_with_geq_id(nid_t nid) = 0;
        -:   51:
        -:   52:    };
        -:   53:
        -:   54:    // Very basic (adjacency list) representation of an undirected graph.
    #####:   55:    class UGraph : public Graph
        -:   56:    {
        -:   57:    private:
        -:   58:        nid_t node_count, edge_count;
        -:   59:        std::unordered_map<nid_t, nid_t> degrees;
        -:   60:        std::unordered_map<nid_t, std::vector<nid_t>> adjacency_list;
        -:   61:
        -:   62:        bool has_node(nid_t nid);
        -:   63:        bool has_edge(nid_t s, nid_t t);
        -:   64:        void add_node(nid_t nid);
        -:   65:        void add_edge(nid_t s, nid_t t);
        -:   66:
        -:   67:    public:
        -:   68:        // Construct UGraph from edgelist. IDs in edgelist are mapped to
        -:   69:        // [0, 1, ..., num_nodes-1]. Removes any self-edges.
        -:   70:        UGraph(std::string edgelist_path);
        -:   71:        std::unordered_map<nid_t, nid_t> node_map; // el id -> UGraph id
        -:   72:        std::unordered_map<nid_t, nid_t> node_map_r; // UGraph id -> el id
        -:   73:
        -:   74:        virtual nid_t num_nodes() override;
        -:   75:        virtual nid_t num_edges() override;
        -:   76:        virtual nid_t degree(nid_t nid) override;
        -:   77:        virtual nid_t in_degree(nid_t nid) override;
        -:   78:        virtual nid_t out_degree(nid_t nid) override;
        -:   79:
        -:   80:        std::vector<nid_t> neighbors_with_geq_id(nid_t nid) override;
        -:   81:    };
        -:   82:
        -:   83:    // Compressed sparserow (CSR) for undirected graphs.
        -:   84:    class CSRUGraph : public Graph
        -:   85:    {
        -:   86:    private:
        -:   87:        nid_t *edges;   // All edgelists, concatenated.
        -:   88:        nid_t *offsets; // For each node, into edges.
        -:   89:        nid_t node_count, edge_count;
        -:   90:        nid_t first_free_id, edges_seen;
        -:   91:
        -:   92:    public:
        -:   93:        std::unordered_map<nid_t, nid_t> nid_to_offset;
        -:   94:        nid_t *offset_to_nid;
        -:   95:
        -:   96:        CSRUGraph(nid_t num_nodes, nid_t num_edges);
        -:   97:        ~CSRUGraph();
        -:   98:
        -:   99:        /// Inserts node_id and its edges. Once inserted, edges
        -:  100:        /// can't be altered for this node.
        -:  101:        void insert_node(nid_t node_id, std::vector<nid_t> nbr_ids);
        -:  102:        void fix_edge_ids(); // this should go...
        -:  103:
        -:  104:        virtual nid_t num_nodes() override;
        -:  105:        virtual nid_t num_edges() override;
        -:  106:        virtual nid_t degree(nid_t nid) override;
        -:  107:        virtual nid_t in_degree(nid_t nid) override;
        -:  108:        virtual nid_t out_degree(nid_t nid) override;
        -:  109:
        -:  110:        nid_t nbr_id_for_node(nid_t nid, nid_t nbr_no);
        -:  111:    };
        -:  112:}
        -:  113:
        -:  114:#endif /* Graph_h */
